
/JVM (Java Virtual Machine): During the development of Java, the developers faced many problems because as the OS gets updated, the system was not able to run the previously written codes. To rectify this problem, JVM came into existence. It is an abstract machine that is present in the user’s computer and converts the bytecode into machine code.

JRE (Java Runtime Environment): JRE refers to a software package in which java bytecode can be executed. It implements the JVM (Java Virtual Machine) and provides all the class libraries and other support files that JVM uses at runtime.


JDK (Java Development Kit): This tool is necessary to compile, document and package Java programs. The JDK includes JRE which contains tools for Java programmers. Along with JRE, it includes an interpreter/loader.


DT: 29/06/2021 nandini.paras@revature.com
mark and sweep algo used for garbage collection,Mark the objecs and sweeps the memory in a rapid way.
java is bottom to top
compiler/Interpretor
src code -> fileName.java
given this file to javacompiler
javac(java Compiler) fileName.java
 
on Success compilation we get
fileName.class(it Could be bytecode/object code/machine understandable code)

import java.util.Calendar; (Best Practice)
import java.util.*; (Bad Practice)
user defined package
package mypack; 
class MyClass{
}

.class in bin
src :  java code
____________________________________________
java use 'default' as default access modifer
public class FirstJavaClass{}
default : within the folder like ur friends within the package
private : only me
protected  means : relationship should be there
public : access everywhere
we can't have two public class in same .java file
we can have any number of default classes
we can't have private,protected classes as outer classes(ouside of class means class classname{psvm{}}, but we can have inner private protected public default static classes outside of main within the psvm.
classname and file name should be same
follow name convention => MyFirstJavaClass
compiler follow naming convention for subclasses
mainclassname$subclassname
___________________________________________________
public static void main(String[] args){}
execution starts from main from { and ends at } whatever code we have will be executed.
why public : jre is outside so that he can enter into our class and execute our class
jvm resides in jre
why static : 
jvm gets memory from os and divide it into two parts
1) storage area ex: HDD/HEAP permanenet
2) execution area RAM/ STACK temp
whatever method/class bring it in stack and throw it back
all the non-static things will be in storage area
all the static things will be in execution area
in stack java inter preter resides. all static directly loaded into stack
you can accessed it without creating objects of it.

why not everything will be static?
java not 100% oops
2 reasons
1. static voilating oops(says everyting should be acces via class and objects)
2. primitives datatypes
static : if we load everything memory will get overflow.
class product{
double price; //uncommon;
String pname; //uncommon;
static float discountonAll_product; //common
}

why void? : does not return anything

why main?  : just name of the method to start execution or we can say entry point
we can see entry point board on gate of mal,  we can say entry point.

why (String[] args) : why String only? : everyone will have their own mother tongue so same case here java mother tongue is String-> java READ/WRITE everything in STRING.
[] args ? : for passing multiple inputs thru commands
real life example debit card and ATM

____________________________
29/6/2021 3:34pm

Data Type => The one which describes type of the memory which I want to hold the data.
for every type comes with its own size.

Java has 8 primitive data types which are dynamically allocated.
int x = 100; 'x' is a variable of type int which having 4bytes of memory holding the value 100;
String s = "String";  's' is a object of String Class which is pointing to the reference(Memory address) of the Hello not the value.

8 data types and its size
(whole numbers)
1. byte 1-byte default value 0;

2. short 2-bytes default value 0

3. int 4-bytes default value 0

4. long 8-bytes default value 0L. must put L at the end otherwise considered as int.

(decimal values are larger than whole numbers)
5. float 4-bytes default value 0.00000f

6. double 8-bytes default value 0.00000f(any decimal values in java by default considered as double)

7. char 2-bytes '\u0000' why 2 bytes? : It supports 1-byte(ASCIII) and 1-byte(UNICODE) = 2-bytes.

8. boolean 1bit false by default/true
_________________________________________________
Type casting : conversion of one of the compatible types to another one.
1) Implicit: smaller size of type is assigned to larger size of type(taken care by the compiler)
ex:
double d = f; float to double
d = m //long to double 
f = x //int to float

2) Explicit : larger type in size when we assign it to smaller type in size (which should be done by programmer explicitly)
ex:
int c = 98 ;
char s = (char)c; //explicit
println(s); // b

float f1 = 22.44f;
int i = (int)f1;
println(i) // 22
long to int will be explicit
float to long will be implicit
to knw the range of int: 
println(Integer.MAX_VALUE); //similar for other primitives.

______________________________________________________________________
29/06/2021 4:02PM
public static_nonstatic_eg;
//importing the public static_nonstatic_eg2 for accessing that class
import static_nonstatic_eg2.Hello; //similar to  import java.util.Scanner;

public class Demo1{
public static void main(String[] args){
System.out.println("Hello from main");
iamStatic();
Demo1 d = new Demo1();
d.iamNonStatic();
d.iamNonStaticAgain();
Calculator.iamStatic() //static method of other class
Calculator  c = new Calculator();
c.iamNonStatic();
c.iamNonStaticAgain();

Hello h = new Hello();
h.iamNonStaticAgain(); //not accessible because there is no public beside that method,it took by default default.
}//main

public static void iamStatic(){
System.out.println("Iam static from same class");
}//iamStatic

public void iamNonStatic(){
System.out.println("Iam non static from demo1 class");
}//iamNonStatic
public void iamNonStaticAgain(){
System.out.println("Iam non static Again from demo1 class");
}//iamNonStaticAgain
}//demo1
_________________________________________________
Calculator.java //diff file but in same package
public static_nonstatic_eg;
public class Calculator
{
public static void iamStatic()
{
	System.out.println("Iam static from claculator same class");
}//iamStatic

public void iamNonStatic()
{
	System.out.println("Iam non static from calculator class");
}//iamNonStatic
public  void iamNonStaticAgain()
{
	System.out.println("Iam non static Again from Calulator class");
}//iamNonStaticAgain
}//calculator
Constructor chaining is the process of calling one constructor from 
another constructor with respect to current object.
Constructor chaining can be done in two ways:

Within same class: It can be done using this() keyword for constructors in same class
From base class: by using super() keyword to call constructor from the base class.
==============================================================
Hello.java //from different package
package static_nonstatic_eg2;
public class Hello
{
public static void iamStatic()
{
	System.out.println("Iam static from claculator same class");
}//iamStatic

public void iamNonStatic()
{
	System.out.println("Iam non static from calculator class");
}//iamNonStatic

 void iamNonStaticAgain()
{
	System.out.println("Iam non static Again from Calulator class");
}//iamNonStaticAgain
}//hello class end
_________________________________________________________________
File Name : Product.java
Package Name : package static_nonstatic_eg3;

public class Product{
int x;
int y; 
//here x and y are called global object/instance level varibles
static int z; // z is called as global class level variable(Common to all objects)

public static void main(String[] args){

	Product p1 = new Product();
	p1.x = 99;
	p1.y = 100;
	System.out.println("Printing for p1");
	p1.printXYZ();

	Product p2 = new Product();
	p2.x = 66;
	p2.y = 100000;
	p2.z = 8888;
	System.out.println("Printing for p2");
	p2.printXYZ();

	System.out.println("Printing for p1 again");
	p1.printXYZ();

}//main

public void printXYZ()
{
	System.out.println("x = "+x);
	System.out.println("y = "+y);
	System.out.println("z = "+z);

}//printXYZ
}//product
local var is shawdod with global var by using 'this' keyword
default value of any object is null
rightclick>source>generateconstructorsforallfields
constructor chaining should be in one line
__________________________________________________________________________________________________________________
30/06/2021 10:08AM
overriding is possible only when there is parent child relationship
single : one parent one child
Hierarchical Inheritance : one parent 3childs all inherit from one parent
multilevel inheritance : parent<c1<c2
mutiple : sup1 sup2 sub class inherits from bth not supported in java
hybrid (hie+multi/any two things together hybrid) not supported in java
object class is the superclass of all the classes
objname.getclass() //use to print package and classname
objname.gethashcode //print hashcode of a class
java follows bottom-up approcah
constructor invoking is from top to bottom
interpretor goes top to bottom line by line.
________________________________________________________________
In method overloading return type could be anything, only thing is parameters should not be different.
@overriding : same name & same parameters
modification of a existing feature of a parent in child class
we can override sub class method in subclass itself
all this done at runtime. because memory is allocated at runtime.

we can't override anything which is static.(bcoz we can'ts access static with obj only which is related to object can be ovveride)
final methods also can't be override.
for doing ovverind there must be parent child relationship, same name and paras. only updating behaviour in child class of a parent method.
parent method and child method visibility(access modifier) should be same. but u cannot decrease the visibility means(if parent is public then we can't have child method as protected or others bcoz public is higher than all of them)
public>protected>default>private
annotation comes into picture from java v7
what is annotations?
basically it reminds the developer there is a typo mismatch in the method name of the parent and child class.
we can make it remind them by using
@Override just above the override method in child class.first letter should be caps of annotations
____________________________________________________________________
3:46pm
object casting : Where a child class object will be converted to parent and vice versa.
when inheritance then only we can cast object.
there are two types of object casting:
1) Implicit casting : taken care by the compiler smaller -> Bigger
Bigger = parent class, Smaller - child class.
MobileV3 v3 = new MobileV3();
Object o = v3;
o can access its own methods and if any of his methods are overridden/updated in child.

2)Explicit casting larger to - > smaller
MobileV1 v1 = (MobileV1)o;
v1 can access his methods and his parents methods and any of his methods if it is updated or overridden in the child class.
 
Object o = new MobileV2(); //implicit
Object o = v3; //implicit
4:42
where do we apply above concept?
ans: for comparing two objects we are using
comparison operators only for primitive datatypes
if do then it will compare memeory adress
ClassCastException in java is a run time error it occurs when an object can not be casted to another type.
____________________________________________________________________________________________
5:09
Abstraction: a class is said to be an abstract class if it having at least one abstract method.
abstract won't have any body so we can't create object of abstract methods
abstract methods cannot be static(already defined n loaded) or final
abstract class dont have constructors
abstraction can be achieved by using interface concept.
abstract methods can have abstract methods as well non abstract methods
by creating the object of child class we can call abstract class methods. make sure that your subclass should be non abstract.
abstract method/class can have access to any access modifer but can't downgraded it
___________________________________________________________________
01/07/2021
10:00AM
using constructors u can't update everytime bcoz it agains create objects.
so we take help of setters and getters to update fields manyway.

All Abstract, default and static methods in an interface are implicitly PUBLIC,
so u can omit the public modifier.
All constants values defined in an interface are impi PUBLIC,

STATIC AND FINAL. u can omit public.
Abstract:                                      Interface
1. abstract class uses abstract keyword        1. Interface use interface as keywords to define themselves they are just class itself
2. We can extend only one class		       2. We can implement any number of interfaces
3. any class default visibi will be default    3. any variables declared in interface is considered as static and final & methods() as public and abstract
4. to make anything as static and final in     4. No Constructors
   in classes we must use those keywords	
5. We can have overloaded constructors which   5. no such thing 
   can be invoked by the child class constr
   using super class
6. for classes we use extends keyword	       6. implements keyword

from java8 it is allowed to have default methods in interface.
anthing which is abstract cannot be instantiTED rather we use chid clas 

//L.H.S should be interface and right hand side should
	//be its implementing class(code to interface) 

1.An interface can extends another interface
public interface childInterface extends ParentInterface{}
if we want to implement innerInterface we need to do
public class Imp1 implements ChildInterface, ChildInterface.InnerInterface{}


2. We can have innerclasses in interface
public class imp1 extends ChildInterface.Innerclass{}

3. Static methods allowed in interfaces from JAVA 8
mising one point

Interface are of 3 types
1) Normal Interface : Interface with any number of abstract methods in it.
2) Functional Interface : with only and only one abstract method but u can have any number of non abstract methods.
3) Marker Interface : Interface with no abstract methods at all, which is use by compiler to mark that it does some job.
eg: serilizable

//Lamda Expression (->) it is used to give the defination for abstract method of funtional Interface only.
it is only use for functional interface
we use @FunctionalInterface annotation before the public interface HelloFromFn1{}
by using we functional interface we can have multiple defination for same method.
we will be dealing with marker interface in files concepts.
_____________________________________________________________________________________
1:05 Wrappers and String Class
Java5- Collections relased.
will accept only and only objects
int -> integer
int x = 10;
Integer i = 10; // i is refereing to addres of x
comes in java.lang package.
Integer is a class
Integer.MAX_VALUE here integer is a class and Max_VALUE IS METHOD.
for STRINGS AND 8 WRAPPER CLASSES so we dont have to use new keyword over there bcoz we have common string pool in heap given by jvm.
String  s = "Hello"; //no new keyword req
s4 = s4.intern(); //brings s4 from heap general memeory to string common pool.
.equlasIgnoreCase() will ignore case senitive hello and Hello will be True;
.equals() // strictly case sensitive hello and Hello will be false
String s1 = "hello"
s1.startsWith("he");  true
s1.endsWith("llo"); true
s1.constains("ello"); /true
s1.contains("lol"); //false
s1.contains("e"); tryue
if u assign s1.replace("l","m") then it will replce else it will remain hello
Integer i = 10; //no new keyword req
object will point to adress of value
String s4 = new String("hey");
devloper want sperate memory inside heap but outside common string pool.
in case of string == checks the memory adrress
in case of string .equals() checks the value

autoboxing : int x = 100;
	     Integer i1 = x;
automatically encapsulating the primitive to its equivalent wrapper class.
compareTo():
_____________________________________________________________________________________
3:37PM
character wrapper class
String s = "A S d    !@_ dsk1239AX1iK>_f";
character demo methods pending
_________________________________________________________
Reg-Ex - 
[] = represents expression
{} = represents length
^ = not
[a-z]{3} = any 3 lower case character are accepted
[A-Z0-9]{5} = any combination of 5 uppercase with digits are accepted
[A-z]{5}[0-9]{4} = five Upper case letters followed by 4 digits.
[a-zA-Z]{2,8} = any word of min length of 2 and max length of 8
[0-9]{1,} = minimum length is 1 and max can be infinite
[^0-9] = apart from digits anything

String s = "JKHPS1586P";
if(s!=null && s.matches("[A-Z]{5}[0-9]{4}[A-Z]{1}"))
	println("Valid PAN");
else
	println("NOT VALID");

Task- write regex for all the govt id's you have(license,uid,bikenumber)
____________________________________________________________________________________
4:16pm- StringBuffer and StringBuilder
String and StringBuffer and StringBuilder are final classes coz they don't have any parent child
relationship.
- StringBuffer and StringBuilder are mutable objects
- They can update in same memory itself.
- There is no common pool for these both which means you must create them using new keyword only.
- StringBuffer is thread safe and StringBuilder is not Thread Safe, thread-safe means
that a method or class instance can be used by multiple threads at the same time
 without any problems occurring.
-StringBuffer is less efficient than StringBuilder.
--Use StringBuffer when you have data that is frequently updated time to time ex:Calculator app or text editor. and use String when your data is fixed such as form data.
//4 constructors in String Buffer
StringBuffer()
StringBuffer(CharSequence seq)
StringBuffer(String str)
StringBuffer(int capacity)
//some predefined methods
public synchronized int length(),capacity(),append(),insert(),reverse(),delete(),deleteCharAt(),replace(),ensureCapacity(),charAt(),indexOf(),lastIndexOf(),subString(),subSequence(),toString()
______________________________________________________________________________________________
02/07/2021 10:15AM
Arrays println("arr["+i+"] : "+arr[i]);
1. Collection of Similar type
2. Comtiguos memeory location(0->N)
3. Fixed Size(Static in nature)
4. Insertion and Deletion in any position
5. Indexed Based
6. Initiliazed all the locations will be filled with default values of that particular type,
   incase of string and objects default value stored will be null.

foreach loop
for(int x : arr){}
System.out.println(Arrays.toString(arr)) //will print all arrays ele without using loops.
System.out.println(Arrays.binarySearch(arr,position)); //not benifi if duplicate ele there

//copy of array
int arr1[] = Arrays.copyOf(ar,ar.length+10);
println(Arrays.toString(arr1));

//fill for arr1 by default as -1
Arrays.fill(arr1,-1);
println(+Arrays.toString(ar1));

//equals method
Arrays.equals(arr1,arr2); //compares with index and values should be same

//Tasks: 1. Find all the palindrome in an array
	 2. Find all Prime numbers in an array
	 3. Find average of even and odd numbers in array
	 4. Find the characters of a string which are in prime index postion and print them in uppercase
	 5. Find if all the vowels are present in an String or not.
	 6. Find if all the vowels in a proper order of AEIOU is present in string or not.
	 7. Remove all the duplicates in an array
	 8. Remove all the duplicate character from a string
	 9. Print the number which is occuring highest number of times in an array.
	10. Print the 2nd highest number in an array(there will be duplicates)
2-D ARRAY later we will do it
_____________________________________________________________________________________
11:39AM-> Exceptional Handling
07/02/2021 01:15:19 PM

Exception Handling
--------------------------
What is error? What is Exception?
*error is a non recoverable situation.
*exception is something which can be handled and can continue the same
flow of execution.
* basically in any application due to user's input or due to
our logical error it may lead to abnormal termination of a application which
is a very bad practice, an application which terminates abnormally
is considered as 0 quality app and nobody wishes to buy or get such
application.
*Exception handling will help you handle the exceptions which has been
raised and terminate normally with the proper communication to the
end user, where such app which handles all the abnormal status normally
its the app which is sold highest in any market.
*It is always encouraged to write a better exceptional handling to get
a better review or quality about the product.
* There are set of predefined exceptions and there can be created 
some of userdefined or custom exceptions for fulfilling business requirement
too.
* All the predefined Exceptions comes under Throwable class.
* and java.lang.Exception is a super class for all the exceptions
in java.
*There are 2 types of exceptions
  a)Checked Exception(java.lang.Exception) -> this exception forces the progarmmer to handle it
 			at the compile time itself, until the programmer
			handles it, compiler wont allow to run.
			some of Checked exceptions are
			FileNotFoundException, ClassNotFoundException,
			MethodNotFoundException, SQLException and more.
  b)Unchecked Exceptions(java.lang.RuntimeException) -> These exceptions are part of java.lang.RunTimeException
                         which occurs at a run time, it is upto programmer
			weather he wants to handle this or not, if he
			doesnt handle it, it will lead to abnormal termination.
                      few unchecked exceptions are:

			ArithmeticException, NullPointerException,
                        ConcurrentModificationException,
			ArrayIndexOutOfBoundException,
                        StringIndexOutOfBoundException and more.
Exceptions can be handled using:
1)try...catch...finally
2)throws
3)throw 

1)try...catch...finally
---------------------------------
* try is a block of code where we keep the code which is suspected to
generate a exception.
*catch is a handler which handles the exception raised by try block.
*finally is such block of code which is executed despite of exception is 
caught or not, we can use such block to clear our resources.
*a try block should and must be followed by catch or finally, 
u cannot write try alone.
*there can be any number of catch blocks for a single try which should be
written in the order i.e the child class exception should come first and
followed by the rest.
*finally and try will be a single block.
*if no catch you can even write finally, if there is a catch then 
finally comes at the end of all catch blocks.


2)throws
---------------
used to throw multpile exceptions at the method level to the calling method.
use it to force the programmer who is creating the object for that
method will handle it.


3)throw
---------------
used to create the exception object of our own to throw our own customised
exception with our own customised message.



Any app in the world having 3 Layers
1. Presentation Layer(presentation logics to beautify/UI)
2. Business or Application Layer(All the complex logic here)
3. Storage or Persistance or DB Layer (Databse SQL/NO SQL)

Object - super class for all the classes

Throwable class : any exception can be re thrown this layer to this layer.(3tier)
one side it is called as error class and another is Exception class

Diff between Error and Exception
Error: like ur application got crashed which u can't handle.
ex: something which is not controllable like overflow of RAM.
Exception: is some situation which u can handled can control and reovery from
it and communicate with customer and get back that Application live.

1)Throwable
1a) Error : like ur application got crashed which u can't handle.
1b) Exceptionclass is the superclass for all the exception.

1bi) Checked exception(force programmer to handle it): Checked Exception happens when compiler is suspecting this
 particular line definitly going to have error and force programmer to handle it. 
until you don't handle it I won't fix that compilation errors.
Any class that is a direct child of EXCeption class is called CheckedException.

Eg: FileNotFoundException, ClassNotFoundException, SQLException, ParseExeption
another direct class of class Exception is RuntimeException(unChecked Exception)

1bii) RuntimeException(UnChecked Exception((will not force programmer to handle it)) : are the exception in which compiler don't force programmer to handle it,
programmer has its choice either it handle it by using try catch or use some logic or right code in such a way that it does not cause error.

eg: ArithmeticException, NullPointerExeption, ClassCastException,ConcurrentModificationException,
IndexOutOfBoundException(ArrayIndexOutOfBoundException and StringIndexOutOfBoundException)

*if you want to create your own custom CheckedException u will extend it from ExceptionClass directly.
*if you want to create your own custom UnCheckedExceptionthen you will extend it from RuntimeException.
Exceptional Handling:
1) try-catch-finally
catch is only the handler
try - suspecting lines of code to be put here. try finally also acceptable.
catch - it receives from try and handles it.
-try can have any no. of catch blocks but only and only one finally block.
-finally is a block of code which we use for releasing the resources. eg: DB closing connection, file closing.
-finally it executes irrespective of try and catch.

2) throws
this method is suspected to throw erorr. we are declaring there beside method definiton and making programming remind.
hey, this is a block of code which suspected to throws a error. its ur choice handle it or not in advnced boldere kia exeptionn hai.
 throws is info to the programmer


3) throw: when to throw at what scenario i need to throw.
step1 : when the exeception occur our jvm  creates an exeception object whenver an exeption occur in runtime envi which some msg.
step2: it looks throws is it rethrowing then will go back to previous method.
are You handling it? NO then go to main if then also  no? terminate it instead of handling it.
throw is info to the runtime exception
----------------------------------------------------
creates a object of exception and throw.
when someone enters invalid email how can you say that? 
we can!! by using throw with our customize message. that ur email is invalid, java wouldn't tell that, programmer has to do that.
by this java will know that okay in that case java has to throw exception.

Rule : only one catch{} at a time will be executed, because in try if line 2 got exception that time only it will leave try and look for catch{},
it would not look for move for line 3..... if there is no catch try{} will terminate abnormally.
2) Parent exception should be in bottom
what i mean by that is catch(Exception e){} should be the last catch above that u can add Exception class child exception like array,index,arith etc.
____________________________________________________________________
3:38PM Helper Class java.util.Collections; sort(),binarySearch() 
Collections basicallly tries to give solution to a given problem
how? let see
Arrays are of fixed size,having similar type, contiguos memory location, CRUD operations are lengthy.
========Collections Framework===========
- Dynamic in Nature
- Accepts only objects
- Resizable (Don't have to define size)
- anytype(Object)
- Iterable(Don't have to use for loop to see the content,
  we can see it easily using iterator obj).
Root for All the collection is Collection Interface except MAP
1)Iterable
A) Collection<E>(I)
1a) List<E>(I) has three providers i)Vectors<E>(I) uses array internally ii) ArrayList<E>(I) uses arrrays internally iii) LinkedList<E>() uses node like structure to maintain the data.
1b) Queue<E>(I)
1c) Set<E>(I)

I = Interface
E = Generic Type = wil give type compatibility
C = Class

Collection is a root for all the collections and collections is a utility class.

i)Vectors<E>(I) 
- uses array internally
- By default it gives 10 memeory loc, after 10 gets full it will add 10 more.
- Contiguous
-legacy thread safe

ii) ArrayList<E>(I) 
- uses arrrays internally
- resizing capacity 10-> newmem = old + 50%old=10+5=15
  total will be prev 10 + newmem = 25
- not thread safe

iii) LinkedList<E>() 
- uses node like structure to maintain the data.
- resizing capa -> 1 node at a time
- not thread safe
.add()
.set() // update
.get() //get particular ele
.remove() //accept both objects and primitive
.size() //size of ele
.clear() //to clear the list.
.addAll(listname_obj) //union all
list2.retainAll(li1) //intersection of li2 and li1, results will be stored in li2
li2.removeAll(li1) // minus like a-b operation contents of a which are not there in b will be removed and results will be stored in a.    

some helper classes
Collections.reverse(li1);
Collection.shuffle(li1); //everytime we referesh it will shuffle elements
Collections.replace(li1,null,-1);
Collection.sort(li1); //ascending by default make sure you dont have any null values
//print in descending
Collections.sort(li1,Collections.reverseOrder()); //it is an overloaded method
Collections.sort(li1);
Collections.binarySearch(li1,23);
li1.contains(100); //true searches and print true if there.

Difference between Collection and Collections.
Collection is an interface        Collections is a utility class

It is an root interface for      It is an helper class which consist of lots of static methods or helper methods such as binarySearch(), reverseOrder() etc.
all the interfaces such as list,
set,queues etc. except map.
_____________________________________________________
Task- compare the LL and PriorityQuee and come up with code exmple.
________________________________________________
Set<E>(I)
it is unique,unindexed & unordered = internal order(Hashing order generated by hashing object).
1a) HashSet<E>(C) -> i) LinkedHashSet<E>(C)
1b) SortedSet<E>(I) i)NavigableSet<E>(I) i1)TreeSet<E>(C)
all three will be having 16mem location only
- every mem acts as binary tree(much more faster way)
- It will allow only one null value.
- no duplicates no replace shot here.
- hash will not maintained order.
- linked mentained order os set by DLL
- Tree is in sorted order by default and with the help of BST (asc/dse)
  we can't pass null values in Trees thru nullptrexce.  output is in alphabet order.   
.add() //for adding elements
.remove("hi");
treeset.contains("hibernate") //true
.addAll()
.retainAll()
.removeAll()
treeset.size()  
//for removing duplicates.
List<String> list =  Arrays.asList("hello","hello","abc");
Set<String> set = new TreeSet<>(list);
s.o.pln(set)
__________________________________________
5/july/2021
10:30am
Map Interface: 
A Map is an associative array data structre. "Key" -> Value
HashMap is one of the implementation of Map Interface.
*Map is a part of Collections f/w but not under Collection interface.
*Map comes with Key and Value pair where every Value is dependent on the Key.
*Key is unique and value can be duplicated.
* it is unindexed an unordered.
*Map is implemented in HashMap,LinkeHashMap,TreeMap and Hashtable classes.
KeySet() : Group of keys
values() : Group of Values
entrySet() : a record it called entry(key and value) //college n list of students unique and repeated
1)Map<K,V>(I)
1a) HashMap<K,V>(C)
i) LinkedHashMap<K,V>(C)
only deiff between the hashmap and linked hashmap
hash does not maintained order of insertion where as linkedhashmap maintain the order of insertion

1b)SortedMap<K,V>(I)
i)NavigableMap<K,V>(I)
ii)TreeMap<K,V>(C)

*It implements Map, SortedMap and NavigableMap interfaces.
*not synch
* maintains the order of a key by using Comparable/Comparator object.
* key cant be null, any number of values can be null.
* since its sorted its faster for searching n traversing.

1c) Hashtable<K,V>(C) 
-neither key nor value null here
-all the legacy classes are by default Synchronised and thread safe.
-No insetion order
*It implements Map.
* generally known as no null Map or no null table i.e neither a key nor
   a value can be null over here.
*it is thread safe.
* it wont maintain the order of insertion.
_____________________________________________________________________
Map<Integer, String> hm =  new HashMap<>();
hm.put(100,"Java");
hm.put(100,"updated") // it will update from java to updated if we insert another value for a same key
hm.put(null,"jre"); //only one key can be null
hm.put(190,null)
hm.put(190,null) //any no. of values can be null
same above in LinkedHashMap except linkedHashMap preserve the Insertion Order.
Map<Integer,String> lhm = new LinkedHashMap<>();
in TreeMap we can't even insert one null value also, if we do we get error.
In HashTable we can't insert neither of one KEY and Value as NULL.
methods:
ht.put(key,value)
ht.get(key) // returns value
ht.size() //return size of ht
ht.remove(key) //if key gone value also gone.
ht.containsKey(key) //returns true or false
ht.containsValue(value) //returns true or false
ht.keySet() //will give all the keys from hash table
ht.values() // give all the values 
==========================================
How would u iterate one by one? lets c.
-> first extract it into set
Set<Integer> set =  ht.keySet();
for(Integer i : set){
	syso("Key = "+i+" Value = "+he.get(i));
}
---------------------------------------------
another way to iterate thru hashmap
for(Entry<Integer,String> e : ht.entrySet())
{
	syso("Key -> "+e.getKey()+" Value -> "+e.getValue());
}
---------------------------------------------------
Problem sttmt: General common to all Collections
// Remove all key value pairs of any key which is null or any value which is null or if any key is divisible by 10
let say we have this data

Map<Integer, String> hm =  new HashMap<>();
hm.put(100,"Java");
hm.put(100,"updated");
hm.put(1000,"null");
hm.put(2000,"jdk");
hm.put(10,"JavaScript");
hm.put(11,"null");
hm.put(199,"Java1");
hm.put(null,"jre");
for(Entry<Integer,String> e : hm.entryString()){
if(e.getKey() == null || e.getValue() == null || e.getKey()%10==0){
hm.remove(e.getKey()); //concurrentmodification exception
by two objects we are doing two diff operation so getting concu exception.
}
}//fail fast
fail safe
to avoid this exception we are using Enumerator
Enumerator - > read operation from T-B
Iterator - >  read and remove from T-B
ListIterator - > specifically design for List Interface and it can do
add, read, and remove and its Bi-directional.
.hasNext() //check wheather there is any key value pair there or not
.next() read and look for next
____________________________________________________________________
Comparable and Comparator are functional Interfaces.
- T = Functional Interface has only and only one abstract method.
***************Diff comparable and comparator**************
Comparable<T> : Comparator <T> use for SORTING custom objects
java.lang : java.util
int compareTo(Object o); : int compare(Object 01,Object o2);
within the POJO class : defination can be anywhere
compareTo() : compare()
Task : try above with Treeset
Task : repeat same using Product(id,manufacturername, pname,cost,ratings,availability-yes/no) from scractch.
_______________________________________________________________________
12:55pm
Stream API's : 
.stream()
.filter()
.map()
var args - variable number of arguments
you can pass 0 to N number of args of same type
rules : we cannot have 2 var args as params for a method signature
...a ...b wrong you cannot have only
-> You can have any number of normal params but they should be var args i.e var args should be the list in the param list
_______________________________________________________________________________________
FILES CONCEPTS / IO STREAMS
ParentClass:IOStreams
1) ByteStream(byte by byte)
i) InputStream as abstract class
ia) FileInputStream
provided with buckets to process faster
BufferedInputStream

ii) OutputStream as abstract class
iia) FileOutputStream
BufferedOutputStream
we use ObjectInputStream
as java is oops lang
we use ObjectOutputStream for stroing the file objs
2)CharacterStream(char by char)unicode
i) Reader class
ia)FileReader
- BufferedReader

ii) Writer Class
iib) FileWriter
- BufferedWriter
from java 7 try() we can write in try we can skip finaaly block if we use try with resources
InputStream                 OutputStream
**ByteStream(does reading nd writing byte by byte) - InputStream->FileInputStream, BufferedInputStream
	     OutputStream->FileOutputStream, BufferedOutputStream
In bytestream whenever u wanna write data to file u have to convert ur data
to bytes and then u have to write it to the destination.
While reading also the stream gives u byte. convert in into char to get your desired
output.
**CharacterStream(does reading and writing caharacter by character)
	      - Reader -> FileReader,BufferedReader
	      - Writer -> FileWriter, BufferedWriter
In char stream no need to convert it while u read and write.

Note: Use Buffer in both the Byte and Char streams to speed up the reading and
writing process.
_____________________________________________________________________________________________________
3:19PM 
Serialization : 
--------------
serializing and de-serializing a particular object/s in some
persistant area.
Serilizable-- Interface 0 abstract methods
ObjectOutputStream - writeObject
ObjectInputStream - readObject
transient(use this if u dont want to serialize a particular object in a serialized class)
Marker Interface - > Serializable
transient  = anyobject which is sensitve which can be put that keyword cvv
________________________________________________________
Scanner class:
best Practice
int age = Integer.parseInt(sc.nextLine());
syso(age);
_________________________________________________________
Iterable and iterator
_____________________________________________________________
Multithreading:
start() invokes run() {what thread exactly do}
once it reaches Runnable it ready to execute what ever we are wrting in run() that is exeuted
executing run() is called as Running state.
some times it is interrupted
MultiThreading
--------------------------------------
* set of instructions is a program -> any program under exceution is a process
  -> part of this process or tiny process or smallest job of a process
  is basically called as thread. group of these threads sharing the load of 
 process and doing some job parallelly in an application, such app
 we call it as multithreaded app.
*thread basically will help u acheive parallel programming i.e simultaneously
u can do multiple jobs and make your app much smarter and much faster.
remember the app which is faster is appreciated in the market and we have
more customers or clients basically for such app.
* for eg take a MS Word which is actually multithreaded app. so msword is
a process which gets created when u double click on it, so now ur
working on this word doc u do a spelling mistake, for this u have a thread
within a word app which highlights your mistake in red color so that u can
go ahead and correct your spelling, and parallely if u have missed ur grammer
green line u can see coming up between the text asking u to fix your sentence
with proper grammer.
* by default all the java app is single threaded, i.e main is a
application thread created by java.
* when u create a group of threads they are in a race condition to run
and finish their jobs, in which u cant identify which thread is coming
first and which is last.
* whenever a thread gets created in java it will be having 3 things with it
[thread_name,priority,thread_group]  [main,5,main]
priority by default will be 5 or it depends on the thread which is
creating this thread, which ever thread is creating a thread the priority
of that particular thread will be passed to new thread.
MIN_PRIORITY - 1
NORM_PRIORITY - 5
MAX_PRIORITY - 10
*thread has a life cycle -> you have to create a thread i.e you have
to give a name, priority an group for a thread, next phase it will be put into
runnable phase where thread is been checked weather it has permission to
access or not, when thread starts to do its job we call thread is in
running phase, in this running phase it has interrupts which may be
generated to wait or to sleep or if some thread with higher priority is coming
in, once thread completes its running phase it dies.
*remember thread will be given the memory which has been allocated to process and
every thread will be having its own private stack to maintain the data of
the particular thread. 
*there are basically 2 types of thread
a)application/foreground thread - these threads which are designed to manage the
                       foreground operations, the jvm will wait for all these
			threads to complete the job and then only it will exit.
b)deamon/background thread - these threads run in a background of our app mostly
                       desgined for releasing resources or memory, jvm will
			never wait for any background thread to finish the job.
			if all the foreground threads are done with the job
			jvm will exit no matter at that time any background
			thread is running or not. for eg : garbage collector.
*in java, threads can be implemented in 2 ways
a)by extending java.lang.Thread class - where you have all the thread life 
                                        cycle based methods.
b)by implementing java.lang.Runnable interface(preffered) - where you have only
					run() method in which you will give the
					job of thread.
* the threads default behaviour of being in a race condition wont be helpful
when there are commonly shared resources, so you can build a synchronized
block or a method where you can keep the shared data, in this block or
a method only one thread is allowed at a time, until that thread
releases the lock, other thread cant acquire that particular block.
*every thread in a java will be having a unique ID, using which jvm
tracks the behaviour of it, all the status and behaviours are being
managed using ThreadMonitors in java.
*start() is a method using which we can start a particular thread which will
call the run() method. in run() method is what you will be giving the
job of what exactly that thread should do.
---------------------------------------------------------------------
to know where current thread is running is
syso(Thread.currentThread());
//creating thread
Thread t = Thread.currentThread();
t.setName("my main");
t.setPriority(7); //priorities must be in between 1 to 10
Syso(Thread.currentThread()) // Thread[MyThread,7,main]
//creating my own threadclass
public class myThread extends Thread{
@Overide
public void run(){
syso("hello"+Thread.currentThread());
}
.join() : Thread class provides the join() method which allows one thread to wait until another thread completes its execution. 
If t is a Thread object whose thread is currently executing, 
then t. join() will make sure that t is terminated before the next instruction is executed by the program.
synchronized(){}
//explore wait,notify, notifyall()
//try producer-consumer problem
___________________________________________________________________________________________________________
06-july-2021
11:11AM
Why we need Apache's Maven?
- Free
- Open Source F/W
- Easy to use
- Maven is known as Build Automation Tool

Developer's Machine
--------------------
-> Dependencies
- java1.8
- postgres 10.17
- junit5.1 //for tescases
- log4j 2.1
- hibernate 5.1
- spring 4.5
Client Machine
--------------
Install or make available of all depen
to over come this and to avoid heache of doing everything manually we can use Maven
-----------------------------------
Maven maintain evrything as pom.xml file(project object module)
it consist of  congig file, Where we can specify all the depend aboe mentioned.
it connects it to remote repo where all the depn will be availble, from that repo maven download & installed(only when all the testcases cleared)what it requires in to client machines.
all test cases passed then only we can take the application to Production Environment(LIVE).

.exe (windows executable file)
.class (java executable file)
.jar (java archive file)
.war (web archive file)
.ear (enterprise achieve)
src/main/java all java classes go
src/main/resources any config for ur java application (.xml/.prop)
all the test cases will be in src/test/java
all the config files fo java will be in src/test/resources
-----------------------------------------------------------------------------------------------
JUNIT5 latest version is 5
---------
- unit testing framework
- used as TDD(test driven development) tool
- free adn Open source
- from eclipse org
- written using Java devs to perform unit testing on the Java apps.

Testing
-------------
- Unit testing (taking single unit n testing)
- System testing (whole system testing)
- functional/integration testing (end to end testing)
*give quality
*gives values
What is TDD(TEST DRIVEN DEVELOPMENT)?
Imagine a code challenge its all about problem solving, if im not giving sample I/O.
TDD is all about deevloper mind set of wrtitng test cases first then code.
TDD is a style of programming where you write test case first i.e minimal testing thing, once u write the test cases u are aware that wht is expected and go ahead write your code and run the test cases on that you will see weather all test cases pass or not, if any failure is there fixed it and again check .
if u feel i need to give other input and test.
JUnit 4 is use to test our old test cases. for backward compatability
junitenginer all the predfeind classes is there and jnunit-jupyter-api enginer is testing that.
testng-api is for integration testing.
junit-platoform-engine
it is use for testing test cases which is there on platform like maven.
- jupiter-api provides all annotation
- Assertions
helps to compare expected value with actual value
eg: you are testing wheather number is even or not.
if passing even it returns true else false (expected)
assertEquals(true,isEven(4)); //asertion checks wheather test cases pass or not
it just validates wheatever value u r getting from ur methods.
--------------------------------------------------------------
<dependencies>
 <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>5.4.0</version>
        <scope>test</scope>
    </dependency>
 <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>5.4.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
*read about maven architecture:
_________________________________________________________________________
3:30 
Task with JUNIT testing (BUS)
Three-tier architecture is a well-established software application architecture
that organizes applications into three logical and physical computing tiers:

1) The presentation tier, or user interface; 
2) The application tier, where data is processed; and 
3) The data tier, where the data associated with the application is stored and managed.

The chief benefit of three-tier architecture is that because each tier runs on its own infrastructure,
each tier can be developed simultaneously by a separate development team,
and can be updated or scaled as needed without impacting the other tiers.
-----------------------------------------------------------------------------------
Apache's log4j -- useful for creating our own log files.
one log4j is enough for one application
- logging framework
- written using java
- free and open source
-  log4j.properties is a config file which resides in main/resources. In which data is stored in key value format
log :  a log file is a file that records either events that occur in an operating system or other software runs,[1] or messages between different users of a communication software. 
Logging : Logging is the act of keeping a log. In the simplest case, messages are written to a single log file.
Why we need it?
suppose if our application got crashed from customer side and we want to know 
what actually happens so that we can get our app back to live.

log4j has 3 main components:
1. Logger Components : using this we can write our log messages
- Log Level lowest to highest
	0 trace
	1 debug
	2 info //anything to comm with customer
	3 warn //any exception warning
	4 error //any incoming error from system unable to login
	5 fatal // app is crashing (jvm is out of memory)
4 & 5 can't be fixed auto, dev need to fixed
above level(0,1) be deactvt, (2,3,4,5)below level is activated.
Note: log 0 and 1 for dev, 2,3,4,5 for customers.

2) Appender Component : Using we can append output to the console, file, or store the output in DB.

3) Pattern Component :  tells the pattern of the output, You want to display date time etc
- Basically formatting the output on the console.
- strictly CASE-SENSITIVE

Download log4j dependecies from maven repository Google.
we are inside log4j.properties file
To write comment in log file use #
#setting up log level of our app

log4j.rootLogger = TRACE,vinay //  here we can change TRACE to other Log Levels like error warn etc

#variable vinay points to the console.

#configuration of console(vinay) object
log4j.appender.vinay = org.apache.log4j.ConsoleAppender #console.logAppender is a .jar file

# now for pattern output formatting
log4j.appender.vinay.layout = org.apache.log4j.PatternLayout
# Wild card for pattern
# %m - log message
# %n - new line or line break
# %p - log level
# %c - class name
# %d - date and time
# dd-date MM-2 digits of month MMM- short name of month MMMM - full name of the month
# yy - last 2 digits of year yyyy - full year it print
# EEE - short name of the day EEEE - full day name 
# HH - 24 hour hh - 12 hr mm - minutes ss - seconds Z/z - time zone and GMT
eg : 
for exmple:
#let say i want to print the msg and want to got for new line
log4j.appender.vinay.layout.ConversionPatter = %m%n

create ur Main.java class
in that before void main
private static Logger log = Logger.getLogger(Main.class)
//inside main now
Log.trace("Hello from");
Log.debug("Hello from");
Log.info("Hello from");
Log.warn("Hello from");
Log.error("Hello from error");
Log.fatal("Hello from fatal");
----------------------------------------------------
anyfile name just end it with .log extension
eg: applogs.log
___________________________________________________________________
Design pattern is to make ur code Readable, more understandable can add modules if required
- GOF(Gang of Four) Patterns
------------------------------
1) Creational 
2) Behavioural
3) Structural
_________________________________________________________________________________________
07/07/2021
----------
10:21 - project zero dicussion 
1-1 from 10:45 to 1pm
QC and Quiz from 4 to 6pm
===========================================
What is RDBMS?
Normalization(1NF,2NF,3NF)
What are ACID Properties
_____________________________________________________________________________________
08-07-2021
check word file.
_______________
26-7-2021
Before AWS:
Suppose you want to host a website, these are the following things that you would need to do:
1) Buying a stack of servers
2) if high traffic maintaince? more servers
3) Monitoring and Maintain servers

if you consider costs then this setup is expensive
troubleshooting problems can be tedious and may conflict with your business goals.
since the traffic is varying, your servers will be idle most of the time.
What is cloud? Cloud is a huge space which has many services available you can just go and rent those services as we want on a rent basis
-------------------------------------------------
28/7/2021 11pm
docker hub : public docker image
spring web
change port
server.port = 9000
conternezation : technqiue rather run on vm we can run on docker
docker archi
docker engine : docker
client can be cmd or shell
docker_host : docker daemon : it listen the commands internally it convert into restapi calls and see the command and execute it 
docker have images it takes the image and create docker instance.
here image is nothing the softwares we want.
there are basically two images 1)local registory or remoterepo
2) remote registory or remote repo
from the image we can make containers
if image is not available the docker demon will go in public or remote registory and get it from there

Docker cmd:
docker --version
docker info 
	Image commands : 
		docker images : what images availbe in docker local registry.
		docker rmi id_of_the images or name : To remove an image.
		docker images : to list all the images
		docker pull image_name: to pull image from public repo ex : docker pull ubuntu
	Container commands:
		docker ps container_name: if want to see what containers are running. ex: pull ubuntu
		docker ps -all : to see all container which are running or stopped.
		docker container rm container_name -f :  to remove a container but here images will not remove
		

How to load an image into an contianer?
First create a container:
	docker run  --name name of the container image id or name
	ex : $docker run --name myubuntu -d ubuntu
	$docker run -itd myubuntu bash
here -it means interactive mode thru bash im going to interact with ubuntu
d means keep it running.

$docker exec -it docker_cont_id bash : for running and exeuting.
*****2:30pm
how to convert .jar to docker file
frist generate .jar by maven
second create docker file by cliking on new file -> Dockerfile
copy this in Dockerfile DockerfileFROM openjdk:11COPY ./target/icicibankapp.jar icicibankapp.jarCMD ["java","-jar","icicibankapp.jar"]
open commd with loc where that Dockerfile is located
then type this command
$docker build-t icicibankapp . -f Dockerfile
-t : image tag name
. -f file name

Will get conternzation after running above command.
*remember the port number
next step running that image
$docker run --name iciciapp -p 9000:9000 icicibank.app

28-07-2021 4:30pm
showed java n sql project into docker 
$docker inpsect id_of_container //it will give information realted to container will be dispplayed.
-------------------------------------------------------------------
Elastic Beampack for deplyoing webapps
-------

22-08-2021
-----------
Spring : Spring is a dependency injection framework to make java application loosely coupled.
-> It provides IOC container which we can do dependency injection.
-> Spring framework makes the easy development of JavaEE application.
Dependency Injection : It is an design pattern by following which we can create an application.
----------------------------------------------
*********************************** GIT COMMANDS
$git diff
- is used to see the difference made
$git log --oneline 
- is used to see the sha and other detais
$git log --oneline 
- is used to see details in more clear way
$git branch
- it is used to list the branches
$git branch branch_name
- it is used to create a branch
$git checkout branch_name 
- to move to that branch
$git branch -d existing_br name
- to delete that particular br

$ git checkout -b footer master
- Switch and Create Branch In One Command

$ git log --oneline --decorate --graph --all
- See All Branches chnages and  commit At Once
-> Now we have multiple sets of changes on three different branches. We can't see other branches in the git log output unless we switch to a branch. Wouldn't it be nice if we could see all branches at once in the git log output.

-> As you've hopefully learned by now, the git log command is pretty powerful and can show us this information. We'll use the new --graph and --all flags

-> The --graph flag adds the bullets and lines to the leftmost part of the output. This shows the actual branching that's happening. The --all flag is what displays all of the branches in the repository.


-----------------JAVA INTERNAL EXECUTION-----------------

JIT COMPILER optimizes our code and imporve our code performance.

javacode
abc.java is compiled and check for error if no error found compiler will generate bytecode that is there inside abc.class file.
this file is now passed to runtime block
where class loader will again scans the byte code for errors
and after scanning it is passed to bytecode verifier
this byte code verifer decided where to pass JIT then interpreter or directly to the interpreter.

JIT comes to action when there is some redundant lines that need to be removed and do some special checks, so that interpreter don't have to put extra efforts for interpreting the code.

so after JIT done its part it will pass on the code to the interpreter.

now interpreter executes the code line by line and simultaneoulsy passes to the OS and OS will pass to the hardware and process the output.

so bascially in common terms JIT ease the load of the interpreter and optimizes our code and imporves the code performance.